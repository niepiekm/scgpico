'From Squeak3.9.1 of 2 March 2008 [latest update: #7075] on 18 July 2022 at 4:54:07 pm'!PRDocumentWriter subclass: #PMMarkdownWriter	instanceVariableNames: 'currentPage page'	classVariableNames: ''	poolDictionaries: ''	category: 'PierMigration'!!PMMarkdownWriter commentStamp: 'lr 3/14/2022 15:23' prior: 0!I am a clone of the PRWikiWriter, adapted to produce markdown instead of wiki syntax.!!PMMarkdownWriter methodsFor: 'private' stamp: 'lr 7/14/2022 13:20'!absoluteLinkFor: aLink		"Return the absolute link for this object, if necessary.	External links are immediately returned."		| link target |		link := aLink reference.	(link startsWith: ' http')		ifTrue: [ link := link copyReplaceAll: ' http' with: 'http' ].	link := link copyReplaceAll: ' ' with: '%20'.		link isEmpty ifTrue: [ ^ link ].	aLink isInternal ifFalse: [ 		(((link startsWith: '/archive')			or: [ (link startsWith: '/files') ])			or: [ (link startsWith: '/download') ])			ifTrue: [ link := '%assets_url%', link ].		^ link ].		target := aLink target.	target notNil		ifTrue: [ 			target isFile				ifTrue: [					link := '%assets_url%/files/', (self filePathFor: target) ]				ifFalse: [					| path |					path := target absolutePath.					link := '%base_url%', path ]				].	link := link copyReplaceAll: ' ' with: '%20'.	^ link! !!PMMarkdownWriter methodsFor: 'private' stamp: 'lr 7/13/2022 13:58'!childrenFor: aPrPage	"	PMMarkdownWriter new childrenFor: (PM new pagesNamed: 'bifrost') first	"	^ ((PRChildrenVisitor on: aPrPage) collect: #yourself) reject: #isFile	! !!PMMarkdownWriter methodsFor: 'private' stamp: 'lr 7/6/2022 12:06'!filePathFor: aPRFile	"This returns the actual file path for an uploaded asset."		^ ('/' join: aPRFile file location), '/', aPRFile file filename! !!PMMarkdownWriter methodsFor: 'private' stamp: 'lr 7/12/2022 16:39'!fixedQuery: aQueryString text: aText	^ '[', aText, '](%assets_url%/scgbib/?query=', aQueryString, '&filter=Year)'! !!PMMarkdownWriter methodsFor: 'private' stamp: 'lr 7/12/2022 14:55'!isComponentLink: aLink	^ aLink isInternal and:		[ aLink target notNil			and: [ aLink target isComponent ] ]! !!PMMarkdownWriter methodsFor: 'private' stamp: 'lr 7/12/2022 14:55'!isScgbibQuery: aLink	^ (self isComponentLink: aLink)		and: [ aLink target componentClass = CPQueryBox ]! !!PMMarkdownWriter methodsFor: 'private' stamp: 'lr 3/14/2022 15:22'!lineMatcher	^ PRDocumentParser lineMatcher! !!PMMarkdownWriter methodsFor: 'private' stamp: 'lr 3/14/2022 15:04'!newLine	"lf instead of cr"	stream nextPut: Character lf.	newline := true! !!PMMarkdownWriter methodsFor: 'private' stamp: 'lr 7/12/2022 18:09'!queryStringFor: aLink	^ (aLink parameters detect: [:assoc | assoc key = 'query' ] ifNone: [ 'query' -> '' ]) value.! !!PMMarkdownWriter methodsFor: 'private' stamp: 'lr 7/15/2022 10:09'!redirectUrlFor: aValueLink	| url |	url := aValueLink parameters first value.	(url startsWith: 'http') ifTrue: [ ^ url ].	(url startsWith: '..') ifTrue: [ ^ url ].	(url startsWith: '/download') ifTrue: [ ^ '%assets_url%', url ].	^ '%base_url%', url! !!PMMarkdownWriter methodsFor: 'private' stamp: 'lr 5/20/2022 11:18'!relativeLinkFor: anObject		"Return the relative link for this object, if necessary.	External links are immediately returned."		| link levels prefix |		link := anObject reference.	link isEmpty ifTrue: [ ^ link ].	anObject isInternal ifFalse: [ ^ link ].		link first = $/ ifFalse: [ ^ '?' , link ].		levels := anObject owner absolutePath count: [: each | each = $/].	self assert: levels > 0 description: 'Missing at least one slash'.	prefix := '.'.	levels - 1 timesRepeat: [ prefix := '../', prefix ].		link := prefix, link.	^ '?', link! !!PMMarkdownWriter methodsFor: 'private' stamp: 'lr 7/13/2022 13:32'!tocFor: aPrPage	"	PMMarkdownWriter new tocFor: (PM new pagesNamed: 'bifrost') first	"	^ (aPrPage document children		select: [: each | each class = PRHeader and: [ each level = 1]])! !!PMMarkdownWriter methodsFor: 'visiting' stamp: 'lr 3/14/2022 17:24'!visitAnchor: anObject	"self nextPutAll: anObject class markup; nextPutAll: anObject name; newLine"! !!PMMarkdownWriter methodsFor: 'visiting' stamp: 'lr 3/14/2022 17:25'!visitAnnotatedParagraph: anObject	self halt: 'Encountered an unexpected annotated paragraph'! !!PMMarkdownWriter methodsFor: 'visiting' stamp: 'lr 7/4/2022 16:08'!visitBoldFormat: anObject	self nextPutAll: '**'.	self visitFormat: anObject.	self nextPutAll: '**'! !!PMMarkdownWriter methodsFor: 'visiting' stamp: 'lr 3/14/2022 17:32'!visitDefinitionList: anObject	"TODO"	newline ifFalse: [ self newLine ].	anObject children do: [ :each |		self 			nest: each class markup			do: [ self visit: each ] ]! !!PMMarkdownWriter methodsFor: 'visiting' stamp: 'lr 3/14/2022 15:26'!visitHeader: anObject	anObject level timesRepeat: [ self nextPutAll: '#' ].	super visitHeader: anObject.	self newLine! !!PMMarkdownWriter methodsFor: 'visiting' stamp: 'lr 7/5/2022 16:07'!visitHorizontalRule: anObject	self newLine; nextPutAll: '---'; newLine! !!PMMarkdownWriter methodsFor: 'visiting' stamp: 'lr 7/4/2022 15:58'!visitItalicFormat: anObject	self nextPutAll: '*'.	self visitFormat: anObject.	self nextPutAll: '*'! !!PMMarkdownWriter methodsFor: 'visiting' stamp: 'lr 7/16/2022 18:33'!visitLink: aLink	"TODO: 	- handle embedded pages (as opposed to embedded images) using iframes?	"	| text |		(aLink class = PRMailLink) ifTrue: [		self nextPutAll: '<a href="mailto:', aLink reference, '">', aLink reference, '</a>'.		self newLine.		^ self ].		(aLink class = PRValueLink) ifTrue: [		(aLink reference = 'value:redirect') ifTrue: [			| url |			url := self redirectUrlFor: aLink.			self nextPutAll: '<head><meta http-equiv="refresh" content="1; url=', url, '" /></head>'.			self nextPutAll: '<body><p>Please follow <a href="', url, '">this link</a>.</p></body>'.			^ self ].		(aLink reference = 'value:children') ifTrue: [			(self childrenFor: aLink owner) do: [ : child |				self nextPutAll: '- [', child title, '](', aLink owner name, '/', child name, ')'.				self newLine ].			^ self ].		"Ignore the other kinds"		^ self ].		(aLink isInternal and: [ aLink target class = CPBibFile ]) 		ifTrue: [			| query |			query := self queryStringFor: aLink.			text := aLink text.			text isNil ifTrue: [ text := aLink target title ].			self nextPutAll: (self fixedQuery: query text: text).			^ self ].		(self isComponentLink: aLink)		ifTrue: [			| class |			class := aLink target componentClass.			class = CPQueryBox				ifTrue: [ self nextPutAll: self scgbibForm.					^ self ].			(class = CPFixedQuery)				ifTrue: [					| query |					query := (aLink target component instVarNamed: 'querySpec') queryString.					"query := (aLink parameters detect: [: a | a key = 'query' ]) value."					self nextPutAll: (self fixedQuery: query text: aLink target title).					^ self				].			(class = CPAuthorPage)				ifTrue: [					| query |					query := self queryStringFor: aLink.					query isEmpty ifTrue: [						query := (aLink target component instVarNamed: 'querySpec') queryString.						query isNil ifTrue: [ ^ self ] ].					text := aLink target title.					text isNil ifTrue: [ text := aLink text ].					self nextPutAll: (self fixedQuery: query text: text).					^ self				].		].		"Treat embedded page links as plain lists of links -- 	there is no easy way to support embedding."	aLink isEmbedded ifTrue: [ 		(aLink isInternal 			and: [ aLink target notNil			and: [ aLink target isFile not 			and: [ aLink target isComponent not ]]]) 			ifTrue: [ self nextPutAll: '- ' ]			ifFalse: [ self nextPutAll: '!!' ]		].		self nextPutAll: '['.	aLink hasChildren		ifTrue: [ self visitDocumentGroup: aLink ]		ifFalse: [			text := aLink isInternal				ifTrue: [ 					| target |					target := aLink target.					target notNil						ifTrue: [ target title ]						ifFalse: [ aLink text ]					]				ifFalse: [ aLink text ].			self nextPutAll: text ].			self		nextPutAll: '](';		nextPutAll: (self absoluteLinkFor: aLink);		nextPutAll: ')'.! !!PMMarkdownWriter methodsFor: 'visiting' stamp: 'lr 7/6/2022 10:27'!visitList: anObject	self newLine.	self nest: Character tab asString do: [ super visitList: anObject ]!]style[(19 28 22 34)f2b,f2,f1,f2! !!PMMarkdownWriter methodsFor: 'visiting' stamp: 'lr 7/6/2022 10:30'!visitListItem: anObject	"NB: hack to ignore the first tab to avoid indenting the whole list"	nesting allButFirst do: [ :each | self nextPutAll: each ].	self nextPutAll: '- '.	super visitListItem: anObject.	self newLine! !!PMMarkdownWriter methodsFor: 'visiting' stamp: 'lr 7/16/2022 11:33'!visitPage: anObject	| title |	title := (anObject title copyReplaceAll: '"' with: '').	self nextPutAll: '---';		newLine;		nextPutAll: 'Title: ';		nextPutAll: title;		newLine;		nextPutAll: '---';		newLine;		nextPutAll: '#';		nextPutAll: title;		newLine.	anObject document  ifNotNil: [		self visitDocument: anObject document ]! !!PMMarkdownWriter methodsFor: 'visiting' stamp: 'lr 7/16/2022 11:29'!visitPreformatted: anObject	self nextPutAll: '```'.	self newLine.	anObject children do: [ :each |		self			nextPutAll: each text;			newLine ].	self nextPutAll: '```'.	self newLine.! !!PMMarkdownWriter methodsFor: 'visiting' stamp: 'lr 7/13/2022 16:20'!visitTable: anObject	self newLine.	"Create a fake header with empty headings"	anObject columnCount timesRepeat:		[ self nextPutAll: '| ' ].	self nextPutAll: '|'.	self newLine.	anObject columnCount timesRepeat:		[ self nextPutAll: '|---' ].	self nextPutAll: '|'.	self newLine.	super visitTable: anObject! !!PMMarkdownWriter methodsFor: 'visiting' stamp: 'lr 7/4/2022 16:07'!visitTableCell: anObject	self nextPutAll: anObject class markup.	anObject isAligned ifTrue: [		anObject isAlignedLeft ifTrue: [ self nextPutAll: anObject class markupLeft ].		anObject isAlignedCenter ifTrue: [ self nextPutAll: anObject class markupCenter ].		anObject isAlignedRight ifTrue: [ self nextPutAll: anObject class markupRight ] ].	anObject isHeading ifTrue: [ self nextPutAll: anObject class markupHeading ].	super visitTableCell: anObject! !!PMMarkdownWriter methodsFor: 'visiting' stamp: 'lr 7/13/2022 16:17'!visitTableRow: anObject	super visitTableRow: anObject.	self newLine.! !!PMMarkdownWriter methodsFor: 'visiting' stamp: 'lr 3/14/2022 17:41'!visitText: anObject	"Write out ==anObject=='s text to the receivers output-stream and escape special characters within and at the beginning of a line."	| string key |	string := anObject text.	newline ifTrue: [		key := self lineMatcher keys			detect: [ :each | string beginsWith: each ]			ifNone: [ nil ].		key isNil ifFalse: [			self nextPut: $\; nextPutAll: key.			string := string allButFirst: key size ] ].	self nextPutAll: (PRDocumentParser escape: string)! !!PMMarkdownWriter methodsFor: 'constants' stamp: 'lr 7/11/2022 18:30'!handledComponentTypes	"	PMMarkdownWriter new handledComponentTypes	"	^ { CPQueryBox }! !!PMMarkdownWriter methodsFor: 'constants' stamp: 'lr 7/11/2022 16:33'!scgbibForm	^ '<form method="GET" action="%assets_url%/scgbib"><input type="text" name="query" size="15" maxlength="800"/><input type="submit" value="scg bib"/></form>'! !