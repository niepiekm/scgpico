'From Squeak3.9.1 of 2 March 2008 [latest update: #7075] on 16 July 2022 at 7:16:46 am'!Object subclass: #PM	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'PierMigration'!!PM commentStamp: 'lr 2/9/2022 12:24' prior: 0!This class is a repository of scripts to experiment with approaches to extract content from the SCG Pier.!!PM methodsFor: 'constants' stamp: 'lr 2/16/2022 15:23'!exportDirectory	"path to store the contents of the pier pages.		PM new exportDirectory	"	^ FileDirectory default pathName, '/export'! !!PM methodsFor: 'constants' stamp: 'lr 7/12/2022 14:26'!newline	^ Character cr asString! !!PM methodsFor: 'constants' stamp: 'lr 7/8/2022 15:01'!pagesToIgnore	"These are the types of pages that can be safely ignored when exporting."	^ { 		PRFile			"static folder of uploaded files is already outside of the image"		. PBBlog			"the blog consists of old news items, mainly publications"		. PBPost			"the blog entries"		. PBComment	"comments on the blog posts"		. CPWhatsNew	"used to track updates to the scgbib"		}! !!PM methodsFor: 'scripts' stamp: 'lr 7/12/2022 14:43'!export	"Export all the pages to the store directory.		PM new export	TODO: need to handle other (not exported) page types.	"	| allPages report pages ignored exported notExported |	report := Dictionary new.	exported := OrderedCollection new.	notExported := OrderedCollection new.	allPages := self allPages.	report at: 'All pages' put: allPages.	ignored := allPages select: [:p | self pagesToIgnore includes: p class ].	pages := allPages copy.	pages removeAll: ignored.	report at: 'Pages ignored' put: ignored.		pages		do: [:page | 			page class = PRPage				ifTrue: [ 					self writePage: page.					self writeSidebar: page.					exported addLast: page ]				ifFalse: [ notExported addLast: page ] ].	report at: 'Pages exported' put: exported.	report at: 'Pages not exported' put: notExported.	report at: 'Summary' put: 		'Exported : ', exported size asString, self newline,		'Not exported : ', notExported size asString, self newline,		'Ignored : ', ignored size asString, self newline,		'Total : ', allPages size asString, self newline.	^ report! !!PM methodsFor: 'scripts' stamp: 'lr 2/17/2022 15:53'!fileOutScripts	"file out all the important code to save.		PM new fileOutScripts	"	PM fileOut.	PMMarkdownWriter fileOut.	"Not needed	PRCase fileOutMethod: #md"! !!PM methodsFor: 'scripts' stamp: 'lr 7/16/2022 07:16'!openWorkspace	"	PM new openWorkspace	"	Workspace new contents: 'PM new export.PM new fileOutScripts.PM new allPages.PM new root.PM new notExportedPages.PM new pagesNamed: ''publications''.'; openLabel: 'Workspace'! !!PM methodsFor: 'scripts' stamp: 'lr 7/16/2022 07:15'!openWorkspaces	"	PM new openWorkspaces	"	Workspace new contents: 'PM new export'; openLabel: 'Export contents'.	Workspace new contents: 'PM new fileOutScripts'; openLabel: 'Export code'.	Workspace new contents: 'PM new allPages.PM new pageTypes.PM new root.PM new sidebars.PM new sidebars size.PM new notExportedPages.PM new pagesNamed: ''publications''.'; openLabel: 'Workspace'! !!PM methodsFor: 'helpers' stamp: 'lr 7/8/2022 15:40'!dictByClass: aList	^ self dictByClass: aList classSelector: #class! !!PM methodsFor: 'helpers' stamp: 'lr 7/8/2022 15:40'!dictByClass: aList classSelector: aSelector	| dict |	dict := Dictionary new.	aList do: [: p | | instances |		instances := dict at: (p perform: aSelector) ifAbsentPut: OrderedCollection new.		instances addLast: p ].		^ dict! !!PM methodsFor: 'helpers' stamp: 'lr 2/16/2022 15:23'!ensureStoreDir	"test to ensure that the store directory exists.	self new ensureStoreDir	"	| dir |	dir := FileDirectory default directoryNamed: self exportDirectory.	dir assureExistence.	self assert: dir exists! !!PM methodsFor: 'helpers' stamp: 'lr 7/7/2022 17:34'!hasSidebar: aPage	"Returns whether this page has a sidebar.	"	| docs |	docs := aPage propertyAt: #documents.	^ (docs includesKey: 'sidebar')			and: [ | sidebar |				sidebar := (docs at: 'sidebar').				sidebar notNil					and: [ sidebar hasChildren						and: [ sidebar text isAllSeparators not ] ] ]! !!PM methodsFor: 'helpers' stamp: 'lr 7/13/2022 13:42'!mdFor: aPRStruct 	"PM new mdFor: PM root"	| ws |	ws := WriteStream on: String new.	PMMarkdownWriter write: aPRStruct to: ws.	^ ws contents! !!PM methodsFor: 'helpers' stamp: 'lr 7/7/2022 16:25'!pagePath: aPage fileName: aFileName	"Return the path where a page should be stored.		PM new pagePath: PM root fileName: 'index.md'		PM new pagePath: (PM new pagesNamed: 'oscar') second fileName: 'index.md'	NB: fileName is a parameter so  we can use this for sidebars too.	"	| path |	path := aPage absolutePath.	path last = $/ ifTrue: [ path := path allButLast ].	path := self exportDirectory, path, '/', aFileName.		^ path! !!PM methodsFor: 'helpers' stamp: 'lr 7/8/2022 11:03'!writePage: aPage 	"Write the contents of the page to a file underneath the storeDirectory in	the location specified by its absolutePath.		PM new writePage: PM root	"	| path dir fileName fs |	path := self pagePath: aPage fileName: 'index.md'.	dir := FileDirectory on: (FileDirectory dirPathFor: path).	dir assureExistence.	fileName := FileDirectory localNameFor: path.	fs := dir forceNewFileNamed: fileName.	fs nextPutAll: (self mdFor: aPage);		 close.	^ path! !!PM methodsFor: 'helpers' stamp: 'lr 7/13/2022 13:41'!writeSidebar: aPage 	"Write out the sidebar of this page, if one exists."	| path dir fileName fs sidebar |		(self hasSidebar: aPage) not ifTrue: [ ^ self ].		path := self pagePath: aPage fileName: 'sidebar.md'..	dir := FileDirectory on: (FileDirectory dirPathFor: path).	dir assureExistence.	fileName := FileDirectory localNameFor: path.	fs := dir forceNewFileNamed: fileName.		sidebar := (aPage propertyAt: #documents) at: 'sidebar'.	fs nextPutAll: (self mdFor: sidebar);		 close.	^ path! !!PM methodsFor: 'queries' stamp: 'lr 7/13/2022 15:25'!allEmbeddedPageLinks	"Return a list of all embedded links to pages (rather than files).		PM new allEmbeddedPageLinks	The pages containing embedded links:		(PM new allEmbeddedPageLinks collect: [: ea | ea owner absolutePath ]) asSet asSortedCollection	"	^ (self allLinks 		select: [: l | l isEmbedded 			and: [ l isInternal 			and: [ l target isComponent not ]			and: [ l target isFile not ] ] ])! !!PM methodsFor: 'queries' stamp: 'lr 7/13/2022 15:01'!allLinks	"Return a list of all links in all pages.		PM new allLinks	"	| result |	result := OrderedCollection new. 	"simulate flatCollect:"	(self allPages do: [: each | result addAll: each outgoingReferences ]).	(self sidebars do: [: each | result addAll: (PROutgoingReferences on: each) ]).	^ result! !!PM methodsFor: 'queries' stamp: 'lr 7/13/2022 14:58'!allLinksDict	"Return a dictionary that classifies all the kinds of links.		PM new allLinksDict	"	^ self dictByClass: PM new allLinks! !!PM methodsFor: 'queries' stamp: 'lr 7/13/2022 15:00'!allPages	"Return a list of all reachable pages, starting from the root		PM new allPages	"	| pagesFound pagesToCheck |	pagesFound := Set new.	pagesToCheck := {self root} asOrderedCollection.	[pagesToCheck size > 0]		whileTrue: [| page | 			page := pagesToCheck removeFirst.			page notNil				ifTrue: [(pagesFound includes: page)						ifFalse: [pagesFound add: page.							pagesToCheck								addAll: (page enumerator collect: #yourself)										]]].	^ pagesFound asOrderedCollection! !!PM methodsFor: 'queries' stamp: 'lr 7/12/2022 12:34'!componentLinkDict	"Return a subdictionary of  linkDict just for the component pages.		PM new componentLinkDict	"	| linkDict dict |	dict := Dictionary new.	linkDict := PM new linkDict.	PM new components do: [: p | | path |		path := p absolutePath.		dict at: path put: (linkDict at: path) ].	^ dict! !!PM methodsFor: 'queries' stamp: 'lr 7/12/2022 12:20'!componentTypeDict	"Return a dictionary grouping all component pages by their class		PM new componentTypeDict	"	^ self dictByClass: PM new components classSelector: #componentClass! !!PM methodsFor: 'queries' stamp: 'lr 7/12/2022 12:22'!components	"Return all the PRComponent pages.		PM new components		PM new components collect: #componentClass	"	^ PM new allPages select: [:p | p class = PRComponent]! !!PM methodsFor: 'queries' stamp: 'lr 2/16/2022 15:17'!cpBibFiles	"Return all the CPBibFile pages.		PM new cpBibFiles	"	^ PM new allPages select: [:p | p class = CPBibFile]! !!PM methodsFor: 'queries' stamp: 'lr 7/12/2022 12:34'!linkDict	"Return a dictionary with page paths as keys and pages that link to that path as values		PM new linkDict	"	| dict |	dict := Dictionary new.	"Initiailize to handle pages that have no links."	PM new allPages do: [ : page | dict at: page absolutePath put: Set new ].	PM new allPages do: [ : page | | links |		links := (page outgoingReferences collect: #yourself) asOrderedCollection.		(self hasSidebar: page) ifTrue: [ | sidebar |			sidebar := (page propertyAt: #documents) at: 'sidebar'.			links addAll: (PROutgoingReferences on: sidebar) ].		links do: [ : link |			(link isInternal and: [ link target notNil ])				ifTrue: [ | path |					path := link target absolutePath.					(dict at: path) add: page ] ] ].	^ dict! !!PM methodsFor: 'queries' stamp: 'lr 7/15/2022 10:14'!localRedirects	"		PM new localRedirects	"	^ (PM new valueLinkDict at: 'value:redirect')		reject: [:l | l parameters first value startsWith: 'http']! !!PM methodsFor: 'queries' stamp: 'lr 2/16/2022 15:08'!mimeTypes	"Return the mimetypes of all the PRFile pages.		PM new mimeTypes	"	| filePages dict |	filePages := PM new allPages				select: [:p | p class = PRFile].	dict := Dictionary new.	filePages		do: [:page | (dict at: page file mimetype ifAbsentPut: OrderedCollection new)				addLast: page].	^ dict! !!PM methodsFor: 'queries' stamp: 'lr 7/11/2022 18:38'!notExportedPages	"Return a list of all pages not yet exported.		PM new notExportedPages	"	^ (self allPages  reject: [ : p | self pagesToIgnore, { PRPage } includes: p class ])		reject: [ : p | p isComponent and: [ PMMarkdownWriter new handledComponentTypes includes: p componentClass ] ]! !!PM methodsFor: 'queries' stamp: 'lr 7/8/2022 15:38'!pageTypeDict	"Return a dictionary grouping all pages by their class		PM new pageTypeDict	"	^ self dictByClass: PM new allPages! !!PM methodsFor: 'queries' stamp: 'lr 2/16/2022 14:08'!pagesNamed: aName	"Return the list of pages with the given name."	^ self allPages select: [:page | page name = aName ]! !!PM methodsFor: 'queries' stamp: 'lr 7/7/2022 17:25'!pagesWithSidebars	"		PM new pagesWithSidebars	"	^ PM new allPages select: [: p | self hasSidebar: p ]! !!PM methodsFor: 'queries' stamp: 'lr 2/16/2022 15:12'!prFiles	"Return all the PRFile pages.		PM new prFiles	"	^ PM new allPages select: [:p | p class = PRFile].! !!PM methodsFor: 'queries' stamp: 'lr 2/16/2022 14:04'!root	"Return the root page of the web site.		PM new root	"	^ self class root! !!PM methodsFor: 'queries' stamp: 'lr 2/16/2022 10:13'!rootLinks	"return the internal links of the root page		PM new rootLinks	"		^ self root outgoingReferences select: #isInternal! !!PM methodsFor: 'queries' stamp: 'lr 7/7/2022 17:18'!sidebars	"		PM new sidebars	"	^ PM new pagesWithSidebars collect: [: p | (p propertyAt: #documents) at: 'sidebar' ]! !!PM methodsFor: 'queries' stamp: 'lr 7/11/2022 15:19'!unreachablePages	"Return a dictionary of all page instances that appear not to be reachable from the root.		PM new unreachablePages	Probably we can ignore all these pages.	"	| reachable dict |	reachable := PM new pageTypeDict.	dict := Dictionary new.	reachable keys do: [: class | | unreachable |		unreachable := class allInstances asOrderedCollection.		unreachable removeAll: (reachable at: class).		dict at: class put: unreachable ].	^ dict! !!PM methodsFor: 'queries' stamp: 'lr 7/12/2022 19:32'!valueLinkDict	"		PM new valueLinkDict	"		^ self dictByClass: PM new valueLinks classSelector: #reference! !!PM methodsFor: 'queries' stamp: 'lr 7/12/2022 19:32'!valueLinks	"		PM new valueLinks	"		^ PM new allLinksDict at: PRValueLink! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!PM class	instanceVariableNames: ''!!PM class methodsFor: 'as yet unclassified' stamp: 'lr 2/16/2022 10:20'!root	"Return the root page of the web site.		PM root	"	^ PRKernel instances someElement root! !