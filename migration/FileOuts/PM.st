'From Squeak3.9.1 of 2 March 2008 [latest update: #7075] on 11 July 2022 at 4:35:01 pm'!Object subclass: #PM	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'PierMigration'!!PM commentStamp: 'lr 2/9/2022 12:24' prior: 0!This class is a repository of scripts to experiment with approaches to extract content from the SCG Pier.!!PM methodsFor: 'constants' stamp: 'lr 2/16/2022 15:23'!exportDirectory	"path to store the contents of the pier pages.		PM new exportDirectory	"	^ FileDirectory default pathName, '/export'! !!PM methodsFor: 'constants' stamp: 'lr 7/8/2022 15:01'!pagesToIgnore	"These are the types of pages that can be safely ignored when exporting."	^ { 		PRFile			"static folder of uploaded files is already outside of the image"		. PBBlog			"the blog consists of old news items, mainly publications"		. PBPost			"the blog entries"		. PBComment	"comments on the blog posts"		. CPWhatsNew	"used to track updates to the scgbib"		}! !!PM methodsFor: 'scripts' stamp: 'lr 7/8/2022 14:57'!export	"Export all the pages to the store directory.		PM new export		TODO: need to handle other page types.	"	| pages count |	pages := self allPages reject: [:p | self pagesToIgnore includes: p class ].	count := 0.	pages		do: [:page | 			page class = PRPage				ifTrue: [ 					self writePage: page.					self writeSidebar: page.					count := count + 1 ]].	^ count asString , ' of ' , pages size asString , ' pages exported. (', (pages size - count) asString, ' pages ignored.)'! !!PM methodsFor: 'scripts' stamp: 'lr 2/17/2022 15:53'!fileOutScripts	"file out all the important code to save.		PM new fileOutScripts	"	PM fileOut.	PMMarkdownWriter fileOut.	"Not needed	PRCase fileOutMethod: #md"! !!PM methodsFor: 'helpers' stamp: 'lr 7/8/2022 15:40'!dictByClass: aList	^ self dictByClass: aList classSelector: #class! !!PM methodsFor: 'helpers' stamp: 'lr 7/8/2022 15:40'!dictByClass: aList classSelector: aSelector	| dict |	dict := Dictionary new.	aList do: [: p | | instances |		instances := dict at: (p perform: aSelector) ifAbsentPut: OrderedCollection new.		instances addLast: p ].		^ dict! !!PM methodsFor: 'helpers' stamp: 'lr 2/16/2022 15:23'!ensureStoreDir	"test to ensure that the store directory exists.	self new ensureStoreDir	"	| dir |	dir := FileDirectory default directoryNamed: self exportDirectory.	dir assureExistence.	self assert: dir exists! !!PM methodsFor: 'helpers' stamp: 'lr 7/7/2022 17:34'!hasSidebar: aPage	"Returns whether this page has a sidebar.	"	| docs |	docs := aPage propertyAt: #documents.	^ (docs includesKey: 'sidebar')			and: [ | sidebar |				sidebar := (docs at: 'sidebar').				sidebar notNil					and: [ sidebar hasChildren						and: [ sidebar text isAllSeparators not ] ] ]! !!PM methodsFor: 'helpers' stamp: 'lr 7/4/2022 16:59'!mdFor: aPRPage 	"	PM new mdFor: PM root	"	| ws |	ws := WriteStream on: String new.	PMMarkdownWriter write: aPRPage to: ws.	^ ws contents! !!PM methodsFor: 'helpers' stamp: 'lr 7/7/2022 16:25'!pagePath: aPage fileName: aFileName	"Return the path where a page should be stored.		PM new pagePath: PM root fileName: 'index.md'		PM new pagePath: (PM new pagesNamed: 'oscar') second fileName: 'index.md'	NB: fileName is a parameter so  we can use this for sidebars too.	"	| path |	path := aPage absolutePath.	path last = $/ ifTrue: [ path := path allButLast ].	path := self exportDirectory, path, '/', aFileName.		^ path! !!PM methodsFor: 'helpers' stamp: 'lr 7/8/2022 11:03'!writePage: aPage 	"Write the contents of the page to a file underneath the storeDirectory in	the location specified by its absolutePath.		PM new writePage: PM root	"	| path dir fileName fs |	path := self pagePath: aPage fileName: 'index.md'.	dir := FileDirectory on: (FileDirectory dirPathFor: path).	dir assureExistence.	fileName := FileDirectory localNameFor: path.	fs := dir forceNewFileNamed: fileName.	fs nextPutAll: (self mdFor: aPage);		 close.	^ path! !!PM methodsFor: 'helpers' stamp: 'lr 7/7/2022 17:47'!writeSidebar: aPage 	"Write out the sidebar of this page, if one exists."	| path dir fileName fs sidebar |		(self hasSidebar: aPage) not ifTrue: [ ^ self ].		path := self pagePath: aPage fileName: 'sidebar.md'..	dir := FileDirectory on: (FileDirectory dirPathFor: path).	dir assureExistence.	fileName := FileDirectory localNameFor: path.	fs := dir forceNewFileNamed: fileName.		sidebar := (aPage propertyAt: #documents) at: 'sidebar'.	fs nextPutAll: (self mdFor: sidebar);		 close.	^ path! !!PM methodsFor: 'queries' stamp: 'lr 7/8/2022 15:35'!allLinks	"		PM new allLinks	"	| result |	result := OrderedCollection new. 	"simulate flatCollect:"	(self allPages do: [: each | result addAll: each outgoingReferences ]).	^ result! !!PM methodsFor: 'queries' stamp: 'lr 7/8/2022 15:38'!allLinksDict	"		PM new allLinksDict	"		^ self dictByClass: PM new allLinks! !!PM methodsFor: 'queries' stamp: 'lr 7/5/2022 14:32'!allPages	"Return a list of all reachable pages, starting from the root	PM new allPages	"	| pagesFound pagesToCheck |	pagesFound := Set new.	pagesToCheck := {self root} asOrderedCollection.	[pagesToCheck size > 0]		whileTrue: [| page | 			page := pagesToCheck removeFirst.			page notNil				ifTrue: [(pagesFound includes: page)						ifFalse: [pagesFound add: page.							pagesToCheck								addAll: (page enumerator collect: #yourself)										]]].	^ pagesFound asOrderedCollection! !!PM methodsFor: 'queries' stamp: 'lr 7/11/2022 15:40'!componentTypeDict	"Return a dictionary grouping all pages by their class		PM new componentTypeDict	"	^ self dictByClass: PM new components classSelector: #componentClass! !!PM methodsFor: 'queries' stamp: 'lr 7/11/2022 15:40'!components	"Return all the PRComponent pages.		PM new components		PM new components collect: #componentClass	"	^ PM new allPages select: [:p | p class = PRComponent]! !!PM methodsFor: 'queries' stamp: 'lr 2/16/2022 15:17'!cpBibFiles	"Return all the CPBibFile pages.		PM new cpBibFiles	"	^ PM new allPages select: [:p | p class = CPBibFile]! !!PM methodsFor: 'queries' stamp: 'lr 2/16/2022 15:08'!mimeTypes	"Return the mimetypes of all the PRFile pages.		PM new mimeTypes	"	| filePages dict |	filePages := PM new allPages				select: [:p | p class = PRFile].	dict := Dictionary new.	filePages		do: [:page | (dict at: page file mimetype ifAbsentPut: OrderedCollection new)				addLast: page].	^ dict! !!PM methodsFor: 'queries' stamp: 'lr 7/11/2022 15:21'!notExportedPages	"Return a list of all pages not yet exported.		PM new notExportedPages		PM new dictByClass: PM new notExportedPages	"	^ self allPages reject: [ : p | self pagesToIgnore, { PRPage } includes: p class ]! !!PM methodsFor: 'queries' stamp: 'lr 7/8/2022 15:38'!pageTypeDict	"Return a dictionary grouping all pages by their class		PM new pageTypeDict	"	^ self dictByClass: PM new allPages! !!PM methodsFor: 'queries' stamp: 'lr 2/16/2022 14:08'!pagesNamed: aName	"Return the list of pages with the given name."	^ self allPages select: [:page | page name = aName ]! !!PM methodsFor: 'queries' stamp: 'lr 7/7/2022 17:25'!pagesWithSidebars	"		PM new pagesWithSidebars	"	^ PM new allPages select: [: p | self hasSidebar: p ]! !!PM methodsFor: 'queries' stamp: 'lr 2/16/2022 15:12'!prFiles	"Return all the PRFile pages.		PM new prFiles	"	^ PM new allPages select: [:p | p class = PRFile].! !!PM methodsFor: 'queries' stamp: 'lr 2/16/2022 14:04'!root	"Return the root page of the web site.		PM new root	"	^ self class root! !!PM methodsFor: 'queries' stamp: 'lr 2/16/2022 10:13'!rootLinks	"return the internal links of the root page		PM new rootLinks	"		^ self root outgoingReferences select: #isInternal! !!PM methodsFor: 'queries' stamp: 'lr 7/7/2022 17:18'!sidebars	"		PM new sidebars	"	^ PM new pagesWithSidebars collect: [: p | (p propertyAt: #documents) at: 'sidebar' ]! !!PM methodsFor: 'queries' stamp: 'lr 7/11/2022 15:19'!unreachablePages	"Return a dictionary of all page instances that appear not to be reachable from the root.		PM new unreachablePages	Probably we can ignore all these pages.	"	| reachable dict |	reachable := PM new pageTypeDict.	dict := Dictionary new.	reachable keys do: [: class | | unreachable |		unreachable := class allInstances asOrderedCollection.		unreachable removeAll: (reachable at: class).		dict at: class put: unreachable ].	^ dict! !!PM methodsFor: 'queries' stamp: 'lr 7/8/2022 15:52'!valueLinkDict	"		PM new valueLinkDict	"		^ self dictByClass: (PM new allLinksDict at: PRValueLink) classSelector: #reference! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!PM class	instanceVariableNames: ''!!PM class methodsFor: 'as yet unclassified' stamp: 'lr 2/16/2022 10:20'!root	"Return the root page of the web site.		PM root	"	^ PRKernel instances someElement root! !